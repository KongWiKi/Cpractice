## 指针的学习

### 什么是指针？

**指针**是一个`变量`，其值为`另一个变量的地址`，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

```tex
type *var-name;
```

### 如何使用指针

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

```c
#include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
 
   printf("Address of var variable: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("Address stored in ip variable: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("Value of *ip variable: %d\n", *ip );
 
   return 0;
}
```

* 习惯上在定义指针变量的同时将其初始化为NUL(在stdio.h中定义零值的宏)
```$xslt
int *pa = &a;
```
该变量中*只是一个指针类型的说明符，不是间接寻址运算符。所以，该语句不能理解为将&a的值赋值给pa所指的变量。事实上，它等价于下面两条语句
```$xslt
int *pa;
pa = &a;
```
其含义为：定义一个可以指向整型数据的指针变量pa,并用整型变量a的的地址值对指针变量pa进行初始化，从而使指针变量pa具体指向中心变量a。

### 直接寻址和间接寻址

类比于：变量a所占的存储单元好比于抽屉A，指针变量p所占的内存单元好比于抽屉B，抽屉B中放着抽屉A的钥匙，`直接寻址`好比是直接在抽屉A中取放东西，`间接寻址`好比是先到抽屉B中取出抽屉A的钥匙，然后打开抽屉A，往抽屉A中放取东西。

在指针中*为`间接寻址运算符`，通过该符号，使用指针变量`pa`来存取它所指向的变量a的值。运算时，要求指针已经被正确初始化或者已指向内存中某个确定的存储单元。



### 使用指针的三条准则

* 永远清楚每个指针执行爱过了哪里，指针必须指向一块有意的内存。
* 永远清楚每个指针指向的对象内容是什么。
* 永远不要使用未初始化的指针。



### 按值调用和模拟按引用调用

`按值调用`好比是把你电脑文件夹下的某个文件复制一份给别人，别人想怎么改都对你自己保存的文件没有任何影响。

`模拟按引用调用`好比是你把开机密码告诉别人并允许别人访问你的文件夹一样，所以自己保存的文件很难保持原样。



### 指针与一维数组

因为数组名`a`代表数组的首地址，即元素a[0]的地址&a[0]，所以表达式a+1表示首地址后下一个元素的地址，即第2个元素的a[1]的地址&a[1]。由此a[i]的地址&a[i]可以用a+i表示。所以a[i]的值可以用*(a+i)表示。

```
#include <stdio.h>
int main(){
    int a [5]= {1,2,3,4,5};
   
    printf("元素1的地址为%p,值为%d\n",a, *a);
    printf("元素2的地址为%p,值为%d\n",a+1, *(a+1));
    printf("元素3的地址为%p,值为%d\n",a+2, *(a+2));
    printf("元素4的地址为%p,值为%d\n",a+3, *(a+3));

}

//元素1的地址为0x7ffe469c2340,值为1
//元素2的地址为0x7ffe469c2344,值为2
//元素3的地址为0x7ffe469c2348,值为3
//元素4的地址为0x7ffe469c234c,值为4
```



数组之所以可以用这种方法来引用，是因为数组的下标运算符[ ]实际是以指针作为其操作的。a[i]被编译器解释为表达式*(a+i)，而&a[i]表示取数组a[i]的第i+1(从0开始)个元素的地址，它等价于指针表达式a+i。